var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = BayesianDiscovery","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [BayesianDiscovery]","category":"page"},{"location":"api/#BayesianDiscovery.DerivativeClass","page":"API","title":"BayesianDiscovery.DerivativeClass","text":"DerivativeClass\n\nCreates the derivative class. Includes:\n\nTimeDerivative: Derivatives w.r.t. time\nTimeNames: Names of the time derivatives\nSpaceDerivative: Derivatives w.r.t. space\nSpaceNames: Names of the space derivatives\norderSpace: Order of spatial derivative\norderTime: Order of temporal derivative\nspatialDimension: 1 if [x] 2 if [x,y]\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianDiscovery.Model","page":"API","title":"BayesianDiscovery.Model","text":"Model Structure\n\nInitiates a structure of class Model\n\nArguments\n\nS: Spatial Dimension\nT\nN\nD\nÎ½S\nÎ½T\nbufferSpace\nbufferTime\nbatchSpace\nbatchTime\nlearning_rate\nZ\nU\nBasis\nStates\nÎ›::Function: Library of potential functions\nÎ›names::Vector{String}: Names of components of library of potential functions\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianDiscovery.Pars","page":"API","title":"BayesianDiscovery.Pars","text":"Pars Structure\n\nInitiates a structure of class Pars\n\nArguments\n\nA: basis coefficients\nM: PDE coefficients\nÎ£Z : measurement variance/covariance matrix\nÎ£U: process variance/covariance matrix\ngamma: ssvs latent parameters\nsample_inds: current subsampled indicies for SGD\nF: current F\nFprime: current Fprime\na_R\nA_R\nnu_R\na_Q\nA_Q\nnu_Q\nv0\nv1\nSigma_M\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianDiscovery.Posterior","page":"API","title":"BayesianDiscovery.Posterior","text":"Posterior Struct\n\nInitiates a structure of class Posterior to hold posterior samples\n\nArguments\n\n\n\n\n\n","category":"type"},{"location":"api/#BayesianDiscovery.DEtection-Tuple{Array{Float64, 3}, Vector, Vector, Int64, Int64, Int64, Int64, Float64, Float64, Function, Function, Vector{String}, Vector{String}}","page":"API","title":"BayesianDiscovery.DEtection","text":"DEtection(Y, SpaceStep, TimeStep, Î½S, Î½T, bufferSpace, bufferTime, batchSpace, batchTime, learning_rate, v0, v1, Î›, Î›names)\n\nDEtection sampler function. Can accept missing values in the input data argument. Returns the model, parameters, and posterior values. The model are the model settings. The parameters are the final value of the parameters in from the sampler. The posterior are the saved posterior values.\n\nConsider the function U_t = M(U U_x U_y U_xy ). DEtection() is used to determine M given a library of potential values, Î›(U, âˆ‚U), to search over.  Within the function, partial derivatives are denoted as Î”U_t Î”U_x Î”U_y Î”U_xx  Î”U_xy , so a potential function could be\n\nfunction Î›(U, âˆ‚U){\n  u = U[1]\n  u_x = âˆ‚U[1]\n  u_y = âˆ‚U[2]\n\n  return [u, u_x, u_y, u*u_x, u*u_y]\n}\n\nTo make the function identify the correct partial derivatives, the argument that are passed into âˆ‚U, Î›names, are required. For the example above, Î›names = [Î”U_x, Î”U_y] because the function Î› uses the partial derivatives U_x and U_t.\n\nIf you want to add covariates to the function, a possible Î›(U, âˆ‚U, X) is\n\nfunction Î›(U, âˆ‚U, X){\n  u = U[1]\n  u_x = âˆ‚U[1]\n  u_y = âˆ‚U[2]\n  x1 = X[1]\n  x2 = X[2]\n\n  return [u, u_x, u_y, u*u_x, u*u_y, x1, x2, u*x1, u_x*x2]\n}\n\nwhere Î›names = [Î”U_x, Î”U_y].\n\nRequired Arguments (in order)\n\nY: Input data. Needs to be Array{Float64, 3} or Array{Union{Missing, Float64}, 3} where the dimensions are Space, Time, Components\nSpaceStep: of type StepRangeLen (range function). For example, range(-1, 1, step = 0.1) for 1 dimension and [range(-1, 1, step = 0.1), range(-1, 1, step = 0.1)] for 2.\nTimeStep: of type StepRangeLen (range function). For example, range(-1, 1, step = 0.1).\nÎ½S::Int or Î½S::Vector{Int}: Number of spatial basis functions. \nÎ½T::Int: Number of temporal basis functions\nbufferSpace::Int or bufferSpace::Vector{Int}: Buffer in space.\nbufferTime::Int: \nbatchSpace::Int: \nbatchTime::Int: \nlearning_rate::Float64: \nv0::Float64: \nv1::Float64: \nÎ›::Function: \nÎ›names::Vector{String}: \n\nOptional Arguments\n\nresponse = \"Î”Ut\": Order of the temporal derivative (default first order). Use \"Î”Utt\" for second and so on.\ndegree = 4: Degree of the B-spline. Must be at least one order higher than the highest order partial derivative.\norderTime = 1: Order of the highest order temporal derivative (default âˆ‚U_t)\norderSpace = 3: Order of the highest order spatial derivative (default âˆ‚Uxxx and âˆ‚Uyyy)\nlatent_dim = size(Y, 3): Dimension of the latent space. Default is same as data dimension.\ncovariates = nothing: Additional covariates.\nnits = 2000: Number of samples for the Gibbs sampler.\nburnin = nits / 2: Number of samples to discard as burnin (default is half of nits).\nlearning_rate_end = learning_rate: End learning rate (default is same as initial learning rate).\n\nExamples\n\nY = Array{Float64}(rand, 256, 101, 1) # space x time x component, vectorized in space\nSpaceStep = [range(-1, 1, step = 0.01), range(-1, 1, step = 0.01)]\nTimeStep = range(-1, 1, step = 0.01)\nÎ½S = [10, 10] # number of space basis functions\nÎ½T = 10 # number of time basis functions\nbufferSpace = [2, 2]\nbufferTime = 2\nbatchSpace = 10\nbatchTime = 10\nlearning_rate = 1e-2\nv0 = 1e-4\nv1 = 1e4\n\nÎ›names = [\"U\", \"Î”U_x\", \"Î”U_xx\", \"Î”U_xxx\"]\n\nfunction Î›(U, âˆ‚U)\n\n  Î”U_x = âˆ‚U[1]\n  Î”U_xx = âˆ‚U[2]\n  Î”U_xxx = âˆ‚U[3]\n\n  u = U[1]\n  u_x = Î”U_x[1]\n  u_xx = Î”U_xx[1]\n  u_xxx = Î”U_xxx[1]\n\n  return [u, u^2, u^3,\n    u_x, u * u_x, u^2 * u_x, u^3 * u_x,\n    u_xx, u * u_xx, u^2 * u_xx, u^3 * u_xx,\n    u_xxx, u * u_xxx, u^2 * u_xxx, u^3 * u_xxx]\n\nend\n\n# not run\n# model, pars, posterior = DEtection(Y, SpaceStep, TimeStep, Î½S, Î½T, bufferSpace, bufferTime, batchSpace, batchTime, learning_rate, c, Î›, Î›names)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.bspline-NTuple{4, Any}","page":"API","title":"BayesianDiscovery.bspline","text":"bspline(x, knot_locs, degree, derivative)\n\nCreates a matrix of B-Splines evaluated at each x with specified knot locations and degree. Dimension is (length(x), length(xknotlocs)). Returns the basis matrix and the derivative of the basis matrix.\n\nArguments\n\nx: data\nknot_locs: knot locations\ndegree: degree of the B-Spline\nderivative: order of the derivative for Psi_x\n\nExamples\n\nx = 1:1:30\nknot_locs = 5:5:25\ndegree = 3\nderivative = 1\n\nPsi, Psi_x = bspline(x, knot_locs, degree, derivative)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.construct_state-Tuple{Matrix{Float64}, BayesianDiscovery.DerivativeClass, Matrix{Float64}}","page":"API","title":"BayesianDiscovery.construct_state","text":"constructstate(;A::Array{Float64, 2},                         Timederivative::Dict, Timenames::Vector{String},                         Spacederivative::Dict, Space_names::Vector{String})\n\nCreates a dictionary and corresponding names of the space and time derivatives. Used only for 1 spatial dimension.\n\nArguments\n\nA::Array{Float64, 2}\nBasisDerivative::DerivativeClass\nTheta: Dimension of components diagonal matrix\n\nExamples\n\nProcessDerivative = construct_state(A, BasisDerivative, Theta)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.create_library-Tuple{Function, Vector{String}, Vector{Int64}, BayesianDiscovery.StateClass}","page":"API","title":"BayesianDiscovery.create_library","text":"create_create_library(Î›, Î›names, locs, State)\n\nCreate a matrix of the function Î› evaluated at each location\n\nArguments\n\nÎ›: function\nÎ›names: names of each component of Î›\nllocs: space-time locations to evaluate the function at\nState: StateClass current state of values\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.create_pars-Tuple{Array{Float64, 3}, Vector, Vector, Vector{Int64}, Int64, Int64, Int64, Vector{Float64}, Float64, Function, Function, Vector{String}, Vector{String}}","page":"API","title":"BayesianDiscovery.create_pars","text":"create_pars()\n\nConstructs the parameter and model classes.\n\nSee also Pars, Model.\n\nArguments\n\nY::Array{Float64, 3}: Space x Time x Component data array\nSpaceStep::Vector{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}: Vector of spatial locations [x, y]\nTimeStep::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}: Time samples\nÎ½S::Vector{Int32}: number of spatial basis functions [x, y]\nÎ½T::Int: number of temporal basis functions\nbufferSpace::Vector{Int}: spatial buffer [x, y]\nbufferTime::Int: temporal buffer\nbatchSpace::Int: batch size for space [x, y]\nbatchTime::Int: batch size for time\nlearning_rate::Float64: learning rate\nv0::Float64: ssvs not included variance\nv1::Float64: ssvs included variance\nÎ›::Function: function library\nÎ›names::Vector{String}: names of arguments in function library\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.derivatives_dictionary-Tuple{Int64, Int64, Int64, Int64, Vector, Vector}","page":"API","title":"BayesianDiscovery.derivatives_dictionary","text":"derivatives_dictionary(;orderx::Int, orderTime::Int, Î½T::Int, Î½S::Int,\n                            Î”x::Float64, Î”t::Float64, degree::Int,\n                            x::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}},\n                            Time::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}})\n\nCreates a dictionary of space and time derivatives and their names. Used only for 1 spactial dimension.\n\nArguments\n\norderx::Int order of the x derivatives (spatial)\norderTime::Int order of the time derivatives\nÎ½T::Int number of time basis functions\nÎ½S::Int number of space basis functions\ndegree::Int degree of bsplines\nx::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}} x (spatial) values\nTime::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}} time values\norderSpace::Int: order of the spatial derivatives\norderTime::Int: order of the time derivative\nÎ½S::Int, Î½S::Array{Int}: either number of spatial basis functions for 1 dimension or [x,y] dimensions\nÎ½T::Int: number of time basis functions\nSpaceStep::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}: in 1 dim spatial indexes or [x,y] spatial indexes\nTimeStep::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}: temporal indexes\ndegree::Int = 4: degree of bspline\n\nExamples\n\nx = 2:0.05:7.5\ny = -2.5:0.05:2.5\nTime = 0:0.08:16\nÎ”t = 0.08\n\nÎ½Sx = 10\nÎ½Sy = 10\nÎ½T = 10\ndegree = 4\norderTime = 1\norderSpace = 3\n\nBasisDerivative = derivatives_dictionary(orderSpace, orderTime, [Î½Sx, Î½Sy], Î½T, [x, y], Time)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.fold3-NTuple{4, Any}","page":"API","title":"BayesianDiscovery.fold3","text":"fold3(Y)\n\nUsed to construct a tensor from the mode-3 matrix Y.\n\nExamples\n\nY3 = unfold3(Y) I = size(Y, 1) J = size(Y, 2) K = size(Y, 3)\n\nY = fold3(Y3, I, J, K)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.make_H-Tuple{Any, Any, Any}","page":"API","title":"BayesianDiscovery.make_H","text":"make_H(M, N, one_inds)\n\nUsed to construct the mapping matrix H\n\nArguments\n\nM::: something\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.sample_inds-Tuple{Vector, Vector, Int64, Int64, Vector{Int64}, Int64}","page":"API","title":"BayesianDiscovery.sample_inds","text":"sample_inds()\n\nreturns the space indices, time indices, and vectorized indices\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.spatial_bspline-NTuple{7, Any}","page":"API","title":"BayesianDiscovery.spatial_bspline","text":"spatial_bspline(x, y, x_knot_locs, y_knot_locs, degree)\n\nCreates a matrix of B-Splines evaluated at each x and y with specified knot locations and degree. Dimension is (length(x)length(y), length(xknotlocs)length(yknotlocs)). Returns the basis matrix and the derivative of the basis matrix.\n\nArguments\n\nx: data in the x direction\ny: data in the x direction\nxknotlocs: knot locations for x\nyknotlocs: knot locations for y\ndegree: degree of the B-Spline\n\nExamples\n\nx = 1:1:30\ny = 1:1:30\nx_knot_locs = 5:5:25\ny_knot_locs = 5:5:25\ndegree = 3\n\nPsi, Psi_x, Psi_y, Psi_xy = spatial_bspline(x, y, x_knot_locs, y_knot_locs, degree)\n\n# plot the functions\nPlots.pyplot()\ncontour(x, y, reshape(Psi, length(x), length(y)), fill = true)\ncontour(x, y, reshape(Psi_x, length(x), length(y)), fill = true)\ncontour(x, y, reshape(Psi_y, length(x), length(y)), fill = true)\ncontour(x, y, reshape(Psi_xy, length(x), length(y)), fill = true)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.tensor_mult-NTuple{4, Any}","page":"API","title":"BayesianDiscovery.tensor_mult","text":"tensor_mult(G, A, B, C)\n\nUsed to multiply a tensor G âˆˆ R(I1, I2, I3) with matrices A âˆˆ R(P, I1), B âˆˆ R(Q, I2), C âˆˆ R(R, I3)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.unfold3-Tuple{Array{Float64, 3}}","page":"API","title":"BayesianDiscovery.unfold3","text":"unfold3(Y)\n\nUsed to get the mode-3 matrix of the tensor Y.\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.update_A!-Tuple{Any, Any}","page":"API","title":"BayesianDiscovery.update_A!","text":"update_A!(pars)\n\nUsed within DEtection() function with a spike-and-slab prior. Updates ğ€ with the elastic net prior (Li 2010) from\n\nğ³(ğ¬ t) = â„‹(ğ¬t) ğš¯ ğ€ (ğ›—phi_t^(0)(t)  ğ›™(ğ¬)) + ğ›œ(ğ¬ t)\n\nğš¯ ğ€ (ğ›—_t^(i)(t)  g(ğ›™(ğ¬))) = ğŒ ğŸ() + ğ›ˆ(ğ¬ t) \n\np(ğ€)  exp-Î»â‚ğ€â‚ - Î»â‚‚ğ€â‚‚Â²\n\nusing Stochastic Gradient Desent with a Constant Learning Rate (Mandt 2016). Î»â‚ and Î»â‚‚ are set to 1/100.\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.update_M!-Tuple{Any, Any}","page":"API","title":"BayesianDiscovery.update_M!","text":"update_M!(pars)\n\nUsed within DEtection() function with a spike-and-slab prior. Updates ğŒ and ğšºáµ¤ from \n\nğš¯ ğ€ (ğ›—_t^(i)(t)  g(ğ›™(ğ¬))) = ğŒ ğŸ() + ğ›ˆ(ğ¬ t) \n\nwhere ğ›ˆ(ğ¬ t)  N_N(0 ğšºáµ¤)and ğšºáµ¤ = diag(ÏƒÂ²áµ¤1  ÏƒÂ²áµ¤N)\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.update_Î£Z!-Tuple{Any, Any}","page":"API","title":"BayesianDiscovery.update_Î£Z!","text":"update_Î£Z!(pars)\n\nUsed within DEtection() function with a spike-and-slab prior. Updates ğšºz from \n\nğ³(ğ¬ t) = â„‹(ğ¬t) ğš¯ ğ€ (ğ›—phi_t^(0)(t)  ğ›™(ğ¬)) + ğ›œ(ğ¬ t)\n\nwhere ğ›œ(ğ¬ t)  N_N(0 ğšºz), ğšºz = diag(ÏƒÂ²z1  ÏƒÂ²zm), and ÏƒÂ²z  Half-t().\n\n\n\n\n\n","category":"method"},{"location":"api/#BayesianDiscovery.Î”L-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Matrix{Float64}}","page":"API","title":"BayesianDiscovery.Î”L","text":"Î”L(z, H, Ïˆ, gÏˆ, Ï•, Ï•_t, Î˜, Î£Zinv, Î£Uinv, A, M, fcurr, fprime)\n\nUsed within DEtection() function. Calculates the gradient of the log likelihood.\n\n\n\n\n\n","category":"method"},{"location":"heat/","page":"Heat Equation","title":"Heat Equation","text":"CurrentModule = BayesianDiscovery","category":"page"},{"location":"heat/#Heat-Example","page":"Heat Equation","title":"Heat Example","text":"","category":"section"},{"location":"heat/","page":"Heat Equation","title":"Heat Equation","text":"This will be an example","category":"page"},{"location":"reactiondiffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"CurrentModule = BayesianDiscovery","category":"page"},{"location":"reactiondiffusion/#Reaction-Diffusion-Example","page":"Reaction Diffusion","title":"Reaction Diffusion Example","text":"","category":"section"},{"location":"reactiondiffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"This will be an example","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BayesianDiscovery","category":"page"},{"location":"#BayesianDiscovery","page":"Home","title":"BayesianDiscovery","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BayesianDiscovery.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BayesianDiscovery]","category":"page"},{"location":"burgers/","page":"Burgers Equation","title":"Burgers Equation","text":"CurrentModule = BayesianDiscovery","category":"page"},{"location":"burgers/#Burgers-Example","page":"Burgers Equation","title":"Burgers Example","text":"","category":"section"},{"location":"burgers/","page":"Burgers Equation","title":"Burgers Equation","text":"This will be an example","category":"page"}]
}
